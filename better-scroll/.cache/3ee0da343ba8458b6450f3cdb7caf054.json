{"dependencies":[],"generated":{"js":"var global = (1,eval)(\"this\");\n/*!\r\n * better-normal-scroll v1.5.4\r\n * (c) 2016-2017 ustbhuangyi\r\n * Released under the MIT License.\r\n */\r\n(function (global, factory) {\r\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n\ttypeof define === 'function' && define.amd ? define(factory) :\r\n\t(global.BScroll = factory());\r\n}(this, (function () { 'use strict';\r\n\r\nvar slicedToArray = function () {\r\n  function sliceIterator(arr, i) {\r\n    var _arr = [];\r\n    var _n = true;\r\n    var _d = false;\r\n    var _e = undefined;\r\n\r\n    try {\r\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\r\n        _arr.push(_s.value);\r\n\r\n        if (i && _arr.length === i) break;\r\n      }\r\n    } catch (err) {\r\n      _d = true;\r\n      _e = err;\r\n    } finally {\r\n      try {\r\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\r\n      } finally {\r\n        if (_d) throw _e;\r\n      }\r\n    }\r\n\r\n    return _arr;\r\n  }\r\n\r\n  return function (arr, i) {\r\n    if (Array.isArray(arr)) {\r\n      return arr;\r\n    } else if (Symbol.iterator in Object(arr)) {\r\n      return sliceIterator(arr, i);\r\n    } else {\r\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\r\n    }\r\n  };\r\n}();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar toConsumableArray = function (arr) {\r\n  if (Array.isArray(arr)) {\r\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\r\n\r\n    return arr2;\r\n  } else {\r\n    return Array.from(arr);\r\n  }\r\n};\r\n\r\nfunction eventMixin(BScroll) {\r\n  BScroll.prototype.on = function (type, fn) {\r\n    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;\r\n\r\n    if (!this._events[type]) {\r\n      this._events[type] = [];\r\n    }\r\n\r\n    this._events[type].push([fn, context]);\r\n  };\r\n\r\n  BScroll.prototype.once = function (type, fn) {\r\n    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;\r\n\r\n    var fired = false;\r\n\r\n    function magic() {\r\n      this.off(type, magic);\r\n\r\n      if (!fired) {\r\n        fired = true;\r\n        fn.apply(context, arguments);\r\n      }\r\n    }\r\n    // 将参数中的回调函数挂载在magic对象的fn属性上,为了执行off方法的时候，暴露对应的函数方法\r\n    magic.fn = fn;\r\n\r\n    this.on(type, magic);\r\n  };\r\n\r\n  BScroll.prototype.off = function (type, fn) {\r\n    var _events = this._events[type];\r\n    if (!_events) {\r\n      return;\r\n    }\r\n\r\n    var count = _events.length;\r\n    while (count--) {\r\n      // 移除通过on或者once绑定的回调函数\r\n      if (_events[count][0] === fn || _events[count][0] && _events[count][0].fn === fn) {\r\n        _events[count][0] = undefined;\r\n      }\r\n    }\r\n  };\r\n\r\n  BScroll.prototype.trigger = function (type) {\r\n    var events = this._events[type];\r\n    if (!events) {\r\n      return;\r\n    }\r\n\r\n    var len = events.length;\r\n    var eventsCopy = [].concat(toConsumableArray(events));\r\n    for (var i = 0; i < len; i++) {\r\n      var event = eventsCopy[i];\r\n\r\n      var _event = slicedToArray(event, 2),\r\n          fn = _event[0],\r\n          context = _event[1];\r\n\r\n      if (fn) {\r\n        fn.apply(context, [].slice.call(arguments, 1));\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nvar ua = navigator.userAgent;\r\n\r\nvar isWeChatDevTools = /wechatdevtools/.test(ua);\r\n\r\nvar elementStyle = document.createElement('div').style;\r\n\r\nvar vendor = function () {\r\n  var transformNames = {\r\n    webkit: 'webkitTransform',\r\n    Moz: 'MozTransform',\r\n    O: 'OTransform',\r\n    ms: 'msTransform',\r\n    standard: 'transform'\r\n  };\r\n\r\n  for (var key in transformNames) {\r\n    if (elementStyle[transformNames[key]] !== undefined) {\r\n      return key;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}();\r\n\r\nfunction prefixStyle(style) {\r\n  if (vendor === false) {\r\n    return false;\r\n  }\r\n\r\n  if (vendor === 'standard') {\r\n    return style;\r\n  }\r\n\r\n  return vendor + style.charAt(0).toUpperCase() + style.substr(1);\r\n}\r\n\r\nfunction addEvent(el, type, fn, capture) {\r\n  el.addEventListener(type, fn, { passive: false, capture: !!capture });\r\n}\r\n\r\nfunction removeEvent(el, type, fn, capture) {\r\n  el.removeEventListener(type, fn, { passive: false, capture: !!capture });\r\n}\r\n\r\nfunction offset(el) {\r\n  var left = 0;\r\n  var top = 0;\r\n\r\n  while (el) {\r\n    left -= el.offsetLeft;\r\n    top -= el.offsetTop;\r\n    el = el.offsetParent;\r\n  }\r\n\r\n  return {\r\n    left: left,\r\n    top: top\r\n  };\r\n}\r\n\r\nvar transform = prefixStyle('transform');\r\n\r\nvar hasPerspective = prefixStyle('perspective') in elementStyle;\r\n// fix issue #361\r\nvar hasTouch = 'ontouchstart' in window || isWeChatDevTools;\r\nvar hasTransform = transform !== false;\r\nvar hasTransition = prefixStyle('transition') in elementStyle;\r\n\r\nvar style = {\r\n  transform: transform,\r\n  transitionTimingFunction: prefixStyle('transitionTimingFunction'),\r\n  transitionDuration: prefixStyle('transitionDuration'),\r\n  transitionProperty: prefixStyle('transitionProperty'),\r\n  transitionDelay: prefixStyle('transitionDelay'),\r\n  transformOrigin: prefixStyle('transformOrigin'),\r\n  transitionEnd: prefixStyle('transitionEnd')\r\n};\r\n\r\nvar TOUCH_EVENT = 1;\r\nvar MOUSE_EVENT = 2;\r\n\r\nvar eventType = {\r\n  touchstart: TOUCH_EVENT,\r\n  touchmove: TOUCH_EVENT,\r\n  touchend: TOUCH_EVENT,\r\n\r\n  mousedown: MOUSE_EVENT,\r\n  mousemove: MOUSE_EVENT,\r\n  mouseup: MOUSE_EVENT\r\n};\r\n\r\nfunction getRect(el) {\r\n  if (el instanceof window.SVGElement) {\r\n    var rect = el.getBoundingClientRect();\r\n    return {\r\n      top: rect.top,\r\n      left: rect.left,\r\n      width: rect.width,\r\n      height: rect.height\r\n    };\r\n  } else {\r\n    return {\r\n      top: el.offsetTop,\r\n      left: el.offsetLeft,\r\n      width: el.offsetWidth,\r\n      height: el.offsetHeight\r\n    };\r\n  }\r\n}\r\n\r\nfunction preventDefaultException(el, exceptions) {\r\n  for (var i in exceptions) {\r\n    if (exceptions[i].test(el[i])) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction tap(e, eventName) {\r\n  var ev = document.createEvent('Event');\r\n  ev.initEvent(eventName, true, true);\r\n  ev.pageX = e.pageX;\r\n  ev.pageY = e.pageY;\r\n  e.target.dispatchEvent(ev);\r\n}\r\n\r\nfunction click(e) {\r\n  var target = e.target;\r\n\r\n  if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {\r\n    var ev = document.createEvent(window.MouseEvent ? 'MouseEvents' : 'Event');\r\n    // cancelable 设置为 false 是为了解决和 fastclick 冲突问题\r\n    ev.initEvent('click', true, false);\r\n    ev._constructed = true;\r\n    target.dispatchEvent(ev);\r\n  }\r\n}\r\n\r\nfunction prepend(el, target) {\r\n  if (target.firstChild) {\r\n    before(el, target.firstChild);\r\n  } else {\r\n    target.appendChild(el);\r\n  }\r\n}\r\n\r\nfunction before(el, target) {\r\n  target.parentNode.insertBefore(el, target);\r\n}\r\n\r\nfunction getNow() {\r\n  return window.performance && window.performance.now ? window.performance.now() + window.performance.timing.navigationStart : +new Date();\r\n}\r\n\r\nfunction extend(target) {\r\n  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n    rest[_key - 1] = arguments[_key];\r\n  }\r\n\r\n  for (var i = 0; i < rest.length; i++) {\r\n    var source = rest[i];\r\n    for (var key in source) {\r\n      target[key] = source[key];\r\n    }\r\n  }\r\n  return target;\r\n}\r\n\r\nvar DEFAULT_OPTIONS = {\r\n  startX: 0,\r\n  startY: 0,\r\n  scrollX: false,\r\n  scrollY: true,\r\n  freeScroll: false,\r\n  directionLockThreshold: 5,\r\n  eventPassthrough: '',\r\n  click: false,\r\n  tap: false,\r\n  bounce: true,\r\n  bounceTime: 700,\r\n  momentum: true,\r\n  momentumLimitTime: 300,\r\n  momentumLimitDistance: 15,\r\n  swipeTime: 2500,\r\n  swipeBounceTime: 500,\r\n  deceleration: 0.001,\r\n  flickLimitTime: 200,\r\n  flickLimitDistance: 100,\r\n  resizePolling: 60,\r\n  probeType: 0,\r\n  preventDefault: true,\r\n  preventDefaultException: {\r\n    tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/\r\n  },\r\n  HWCompositing: true,\r\n  useTransition: true,\r\n  useTransform: true,\r\n  bindToWrapper: false,\r\n  disableMouse: hasTouch,\r\n  disableTouch: !hasTouch,\r\n  observeDOM: true,\r\n  /**\r\n   * for picker\r\n   * wheel: {\r\n   *   selectedIndex: 0,\r\n   *   rotate: 25,\r\n   *   adjustTime: 400\r\n   *   wheelWrapperClass: 'wheel-scroll',\r\n   *   wheelItemClass: 'wheel-item'\r\n   * }\r\n   */\r\n  wheel: false,\r\n  /**\r\n   * for slide\r\n   * snap: {\r\n   *   loop: false,\r\n   *   el: domEl,\r\n   *   threshold: 0.1,\r\n   *   stepX: 100,\r\n   *   stepY: 100,\r\n   *   listenFlick: true\r\n   * }\r\n   */\r\n  snap: false,\r\n  /**\r\n   * for scrollbar\r\n   * scrollbar: {\r\n   *   fade: true\r\n   * }\r\n   */\r\n  scrollbar: false,\r\n  /**\r\n   * for pull down and refresh\r\n   * pullDownRefresh: {\r\n   *   threshold: 50,\r\n   *   stop: 20\r\n   * }\r\n   */\r\n  pullDownRefresh: false,\r\n  /**\r\n   * for pull up and load\r\n   * pullUpLoad: {\r\n   *   threshold: 50\r\n   * }\r\n   */\r\n  pullUpLoad: false\r\n};\r\n\r\nfunction initMixin(BScroll) {\r\n  BScroll.prototype._init = function (el, options) {\r\n    this._handleOptions(options);\r\n\r\n    // init private custom events\r\n    this._events = {};\r\n\r\n    this.x = 0;\r\n    this.y = 0;\r\n    this.directionX = 0;\r\n    this.directionY = 0;\r\n\r\n    this._addDOMEvents();\r\n\r\n    this._initExtFeatures();\r\n\r\n    this._watchTransition();\r\n\r\n    if (this.options.observeDOM) {\r\n      this._initDOMObserver();\r\n    }\r\n\r\n    this.refresh();\r\n\r\n    if (!this.options.snap) {\r\n      this.scrollTo(this.options.startX, this.options.startY);\r\n    }\r\n\r\n    this.enable();\r\n  };\r\n\r\n  BScroll.prototype._handleOptions = function (options) {\r\n    this.options = extend({}, DEFAULT_OPTIONS, options);\r\n\r\n    this.translateZ = this.options.HWCompositing && hasPerspective ? ' translateZ(0)' : '';\r\n\r\n    this.options.useTransition = this.options.useTransition && hasTransition;\r\n    this.options.useTransform = this.options.useTransform && hasTransform;\r\n\r\n    this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;\r\n\r\n    // If you want eventPassthrough I have to lock one of the axes\r\n    this.options.scrollX = this.options.eventPassthrough === 'horizontal' ? false : this.options.scrollX;\r\n    this.options.scrollY = this.options.eventPassthrough === 'vertical' ? false : this.options.scrollY;\r\n\r\n    // With eventPassthrough we also need lockDirection mechanism\r\n    this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;\r\n    this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;\r\n\r\n    if (this.options.tap === true) {\r\n      this.options.tap = 'tap';\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._addDOMEvents = function () {\r\n    var eventOperation = addEvent;\r\n    this._handleDOMEvents(eventOperation);\r\n  };\r\n\r\n  BScroll.prototype._removeDOMEvents = function () {\r\n    var eventOperation = removeEvent;\r\n    this._handleDOMEvents(eventOperation);\r\n  };\r\n\r\n  BScroll.prototype._handleDOMEvents = function (eventOperation) {\r\n    var target = this.options.bindToWrapper ? this.wrapper : window;\r\n    eventOperation(window, 'orientationchange', this);\r\n    eventOperation(window, 'resize', this);\r\n\r\n    if (this.options.click) {\r\n      eventOperation(this.wrapper, 'click', this, true);\r\n    }\r\n\r\n    if (!this.options.disableMouse) {\r\n      eventOperation(this.wrapper, 'mousedown', this);\r\n      eventOperation(target, 'mousemove', this);\r\n      eventOperation(target, 'mousecancel', this);\r\n      eventOperation(target, 'mouseup', this);\r\n    }\r\n\r\n    if (hasTouch && !this.options.disableTouch) {\r\n      eventOperation(this.wrapper, 'touchstart', this);\r\n      eventOperation(target, 'touchmove', this);\r\n      eventOperation(target, 'touchcancel', this);\r\n      eventOperation(target, 'touchend', this);\r\n    }\r\n\r\n    eventOperation(this.scroller, style.transitionEnd, this);\r\n  };\r\n\r\n  BScroll.prototype._initExtFeatures = function () {\r\n    if (this.options.snap) {\r\n      this._initSnap();\r\n    }\r\n    if (this.options.scrollbar) {\r\n      this._initScrollbar();\r\n    }\r\n    if (this.options.pullUpLoad) {\r\n      this._initPullUp();\r\n    }\r\n    if (this.options.pullDownRefresh) {\r\n      this._initPullDown();\r\n    }\r\n    if (this.options.wheel) {\r\n      this._initWheel();\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._watchTransition = function () {\r\n    if (typeof Object.defineProperty !== 'function') {\r\n      return;\r\n    }\r\n    var me = this;\r\n    var isInTransition = false;\r\n    Object.defineProperty(this, 'isInTransition', {\r\n      get: function get() {\r\n        return isInTransition;\r\n      },\r\n      set: function set(newVal) {\r\n        isInTransition = newVal;\r\n        // fix issue #359\r\n        var el = me.scroller.children.length ? me.scroller.children : [me.scroller];\r\n        var pointerEvents = isInTransition ? 'none' : 'auto';\r\n        for (var i = 0; i < el.length; i++) {\r\n          el[i].style.pointerEvents = pointerEvents;\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  BScroll.prototype._initDOMObserver = function () {\r\n    var _this = this;\r\n\r\n    if (typeof MutationObserver !== 'undefined') {\r\n      var timer = void 0;\r\n      var observer = new MutationObserver(function (mutations) {\r\n        // don't do any refresh during the transition, or outside of the boundaries\r\n        if (_this._shouldNotRefresh()) {\r\n          return;\r\n        }\r\n        var immediateRefresh = false;\r\n        var deferredRefresh = false;\r\n        for (var i = 0; i < mutations.length; i++) {\r\n          var mutation = mutations[i];\r\n          if (mutation.type !== 'attributes') {\r\n            immediateRefresh = true;\r\n            break;\r\n          } else {\r\n            if (mutation.target !== _this.scroller) {\r\n              deferredRefresh = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (immediateRefresh) {\r\n          _this.refresh();\r\n        } else if (deferredRefresh) {\r\n          // attributes changes too often\r\n          clearTimeout(timer);\r\n          timer = setTimeout(function () {\r\n            _this.refresh();\r\n          }, 60);\r\n        }\r\n      });\r\n      var config = {\r\n        attributes: true,\r\n        childList: true,\r\n        subtree: true\r\n      };\r\n      observer.observe(this.scroller, config);\r\n\r\n      this.on('destroy', function () {\r\n        observer.disconnect();\r\n      });\r\n    } else {\r\n      this._checkDOMUpdate();\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._shouldNotRefresh = function () {\r\n    var outsideBoundaries = this.x > 0 || this.x < this.maxScrollX || this.y > 0 || this.y < this.maxScrollY;\r\n\r\n    return this.isInTransition || this.stopFromTransition || outsideBoundaries;\r\n  };\r\n\r\n  BScroll.prototype._checkDOMUpdate = function () {\r\n    var scrollerRect = getRect(this.scroller);\r\n    var oldWidth = scrollerRect.width;\r\n    var oldHeight = scrollerRect.height;\r\n\r\n    function check() {\r\n      if (this.destroyed) {\r\n        return;\r\n      }\r\n      scrollerRect = getRect(this.scroller);\r\n      var newWidth = scrollerRect.width;\r\n      var newHeight = scrollerRect.height;\r\n\r\n      if (oldWidth !== newWidth || oldHeight !== newHeight) {\r\n        this.refresh();\r\n      }\r\n      oldWidth = newWidth;\r\n      oldHeight = newHeight;\r\n\r\n      next.call(this);\r\n    }\r\n\r\n    function next() {\r\n      var _this2 = this;\r\n\r\n      setTimeout(function () {\r\n        check.call(_this2);\r\n      }, 1000);\r\n    }\r\n\r\n    next.call(this);\r\n  };\r\n\r\n  BScroll.prototype.handleEvent = function (e) {\r\n    switch (e.type) {\r\n      case 'touchstart':\r\n      case 'mousedown':\r\n        this._start(e);\r\n        break;\r\n      case 'touchmove':\r\n      case 'mousemove':\r\n        this._move(e);\r\n        break;\r\n      case 'touchend':\r\n      case 'mouseup':\r\n      case 'touchcancel':\r\n      case 'mousecancel':\r\n        this._end(e);\r\n        break;\r\n      case 'orientationchange':\r\n      case 'resize':\r\n        this._resize();\r\n        break;\r\n      case 'transitionend':\r\n      case 'webkitTransitionEnd':\r\n      case 'oTransitionEnd':\r\n      case 'MSTransitionEnd':\r\n        this._transitionEnd(e);\r\n        break;\r\n      case 'click':\r\n        if (this.enabled && !e._constructed) {\r\n          if (!preventDefaultException(e.target, this.options.preventDefaultException)) {\r\n            e.preventDefault();\r\n          }\r\n          e.stopPropagation();\r\n        }\r\n        break;\r\n    }\r\n  };\r\n\r\n  BScroll.prototype.refresh = function () {\r\n    var wrapperRect = getRect(this.wrapper);\r\n    this.wrapperWidth = wrapperRect.width;\r\n    this.wrapperHeight = wrapperRect.height;\r\n\r\n    var scrollerRect = getRect(this.scroller);\r\n    this.scrollerWidth = scrollerRect.width;\r\n    this.scrollerHeight = scrollerRect.height;\r\n\r\n    var wheel = this.options.wheel;\r\n    if (wheel) {\r\n      this.items = this.scroller.children;\r\n      this.options.itemHeight = this.itemHeight = this.items.length ? this.scrollerHeight / this.items.length : 0;\r\n      if (this.selectedIndex === undefined) {\r\n        this.selectedIndex = wheel.selectedIndex || 0;\r\n      }\r\n      this.options.startY = -this.selectedIndex * this.itemHeight;\r\n      this.maxScrollX = 0;\r\n      this.maxScrollY = -this.itemHeight * (this.items.length - 1);\r\n    } else {\r\n      this.maxScrollX = this.wrapperWidth - this.scrollerWidth;\r\n      this.maxScrollY = this.wrapperHeight - this.scrollerHeight;\r\n    }\r\n\r\n    this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;\r\n    this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;\r\n\r\n    if (!this.hasHorizontalScroll) {\r\n      this.maxScrollX = 0;\r\n      this.scrollerWidth = this.wrapperWidth;\r\n    }\r\n\r\n    if (!this.hasVerticalScroll) {\r\n      this.maxScrollY = 0;\r\n      this.scrollerHeight = this.wrapperHeight;\r\n    }\r\n\r\n    this.endTime = 0;\r\n    this.directionX = 0;\r\n    this.directionY = 0;\r\n    this.wrapperOffset = offset(this.wrapper);\r\n\r\n    this.trigger('refresh');\r\n\r\n    this.resetPosition();\r\n  };\r\n\r\n  BScroll.prototype.enable = function () {\r\n    this.enabled = true;\r\n  };\r\n\r\n  BScroll.prototype.disable = function () {\r\n    this.enabled = false;\r\n  };\r\n}\r\n\r\nvar ease = {\r\n\t// easeOutQuint\r\n\tswipe: {\r\n\t\tstyle: 'cubic-bezier(0.23, 1, 0.32, 1)',\r\n\t\tfn: function fn(t) {\r\n\t\t\treturn 1 + --t * t * t * t * t;\r\n\t\t}\r\n\t},\r\n\t// easeOutQuard\r\n\tswipeBounce: {\r\n\t\tstyle: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',\r\n\t\tfn: function fn(t) {\r\n\t\t\treturn t * (2 - t);\r\n\t\t}\r\n\t},\r\n\t// easeOutQuart\r\n\tbounce: {\r\n\t\tstyle: 'cubic-bezier(0.165, 0.84, 0.44, 1)',\r\n\t\tfn: function fn(t) {\r\n\t\t\treturn 1 - --t * t * t * t;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nfunction momentum(current, start, time, lowerMargin, wrapperSize, options) {\r\n  var distance = current - start;\r\n  var speed = Math.abs(distance) / time;\r\n\r\n  var deceleration = options.deceleration,\r\n      itemHeight = options.itemHeight,\r\n      swipeBounceTime = options.swipeBounceTime,\r\n      wheel = options.wheel,\r\n      swipeTime = options.swipeTime;\r\n\r\n  var duration = swipeTime;\r\n  var rate = wheel ? 4 : 15;\r\n\r\n  var destination = current + speed / deceleration * (distance < 0 ? -1 : 1);\r\n\r\n  if (wheel && itemHeight) {\r\n    destination = Math.round(destination / itemHeight) * itemHeight;\r\n  }\r\n\r\n  if (destination < lowerMargin) {\r\n    destination = wrapperSize ? lowerMargin - wrapperSize / rate * speed : lowerMargin;\r\n    duration = swipeBounceTime;\r\n  } else if (destination > 0) {\r\n    destination = wrapperSize ? wrapperSize / rate * speed : 0;\r\n    duration = swipeBounceTime;\r\n  }\r\n\r\n  return {\r\n    destination: Math.round(destination),\r\n    duration: duration\r\n  };\r\n}\r\n\r\nvar DEFAULT_INTERVAL = 100 / 60;\r\n\r\nvar requestAnimationFrame = function () {\r\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||\r\n  // if all else fails, use setTimeout\r\n  function (callback) {\r\n    return window.setTimeout(callback, (callback.interval || DEFAULT_INTERVAL) / 2); // make interval as precise as possible.\r\n  };\r\n}();\r\n\r\nvar cancelAnimationFrame = function () {\r\n  return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || function (id) {\r\n    window.clearTimeout(id);\r\n  };\r\n}();\r\n\r\nvar DIRECTION_UP = 1;\r\nvar DIRECTION_DOWN = -1;\r\nvar DIRECTION_LEFT = 1;\r\nvar DIRECTION_RIGHT = -1;\r\n\r\nfunction coreMixin(BScroll) {\r\n  BScroll.prototype._start = function (e) {\r\n    var _eventType = eventType[e.type];\r\n    if (_eventType !== TOUCH_EVENT) {\r\n      if (e.button !== 0) {\r\n        return;\r\n      }\r\n    }\r\n    if (!this.enabled || this.destroyed || this.initiated && this.initiated !== _eventType) {\r\n      return;\r\n    }\r\n    this.initiated = _eventType;\r\n\r\n    if (this.options.preventDefault && !preventDefaultException(e.target, this.options.preventDefaultException)) {\r\n      e.preventDefault();\r\n    }\r\n\r\n    this.moved = false;\r\n    this.distX = 0;\r\n    this.distY = 0;\r\n    this.directionX = 0;\r\n    this.directionY = 0;\r\n    this.movingDirectionX = 0;\r\n    this.movingDirectionY = 0;\r\n    this.directionLocked = 0;\r\n\r\n    this._transitionTime();\r\n    this.startTime = getNow();\r\n\r\n    if (this.options.wheel) {\r\n      this.target = e.target;\r\n    }\r\n\r\n    this.stop();\r\n\r\n    var point = e.touches ? e.touches[0] : e;\r\n\r\n    this.startX = this.x;\r\n    this.startY = this.y;\r\n    this.absStartX = this.x;\r\n    this.absStartY = this.y;\r\n    this.pointX = point.pageX;\r\n    this.pointY = point.pageY;\r\n\r\n    this.trigger('beforeScrollStart');\r\n  };\r\n\r\n  BScroll.prototype._move = function (e) {\r\n    if (!this.enabled || this.destroyed || eventType[e.type] !== this.initiated) {\r\n      return;\r\n    }\r\n\r\n    if (this.options.preventDefault) {\r\n      e.preventDefault();\r\n    }\r\n\r\n    var point = e.touches ? e.touches[0] : e;\r\n    var deltaX = point.pageX - this.pointX;\r\n    var deltaY = point.pageY - this.pointY;\r\n\r\n    this.pointX = point.pageX;\r\n    this.pointY = point.pageY;\r\n\r\n    this.distX += deltaX;\r\n    this.distY += deltaY;\r\n\r\n    var absDistX = Math.abs(this.distX);\r\n    var absDistY = Math.abs(this.distY);\r\n\r\n    var timestamp = getNow();\r\n\r\n    // We need to move at least momentumLimitDistance pixels for the scrolling to initiate\r\n    if (timestamp - this.endTime > this.options.momentumLimitTime && absDistY < this.options.momentumLimitDistance && absDistX < this.options.momentumLimitDistance) {\r\n      return;\r\n    }\r\n\r\n    // If you are scrolling in one direction lock the other\r\n    if (!this.directionLocked && !this.options.freeScroll) {\r\n      if (absDistX > absDistY + this.options.directionLockThreshold) {\r\n        this.directionLocked = 'h'; // lock horizontally\r\n      } else if (absDistY >= absDistX + this.options.directionLockThreshold) {\r\n        this.directionLocked = 'v'; // lock vertically\r\n      } else {\r\n        this.directionLocked = 'n'; // no lock\r\n      }\r\n    }\r\n\r\n    if (this.directionLocked === 'h') {\r\n      if (this.options.eventPassthrough === 'vertical') {\r\n        e.preventDefault();\r\n      } else if (this.options.eventPassthrough === 'horizontal') {\r\n        this.initiated = false;\r\n        return;\r\n      }\r\n      deltaY = 0;\r\n    } else if (this.directionLocked === 'v') {\r\n      if (this.options.eventPassthrough === 'horizontal') {\r\n        e.preventDefault();\r\n      } else if (this.options.eventPassthrough === 'vertical') {\r\n        this.initiated = false;\r\n        return;\r\n      }\r\n      deltaX = 0;\r\n    }\r\n\r\n    deltaX = this.hasHorizontalScroll ? deltaX : 0;\r\n    deltaY = this.hasVerticalScroll ? deltaY : 0;\r\n    this.movingDirectionX = deltaX > 0 ? DIRECTION_RIGHT : deltaX < 0 ? DIRECTION_LEFT : 0;\r\n    this.movingDirectionY = deltaY > 0 ? DIRECTION_DOWN : deltaY < 0 ? DIRECTION_UP : 0;\r\n\r\n    var newX = this.x + deltaX;\r\n    var newY = this.y + deltaY;\r\n\r\n    // Slow down or stop if outside of the boundaries\r\n    if (newX > 0 || newX < this.maxScrollX) {\r\n      if (this.options.bounce) {\r\n        newX = this.x + deltaX / 3;\r\n      } else {\r\n        newX = newX > 0 ? 0 : this.maxScrollX;\r\n      }\r\n    }\r\n    if (newY > 0 || newY < this.maxScrollY) {\r\n      if (this.options.bounce) {\r\n        newY = this.y + deltaY / 3;\r\n      } else {\r\n        newY = newY > 0 ? 0 : this.maxScrollY;\r\n      }\r\n    }\r\n\r\n    if (!this.moved) {\r\n      this.moved = true;\r\n      this.trigger('scrollStart');\r\n    }\r\n\r\n    this._translate(newX, newY);\r\n\r\n    if (timestamp - this.startTime > this.options.momentumLimitTime) {\r\n      this.startTime = timestamp;\r\n      this.startX = this.x;\r\n      this.startY = this.y;\r\n\r\n      if (this.options.probeType === 1) {\r\n        this.trigger('scroll', {\r\n          x: this.x,\r\n          y: this.y\r\n        });\r\n      }\r\n    }\r\n\r\n    if (this.options.probeType > 1) {\r\n      this.trigger('scroll', {\r\n        x: this.x,\r\n        y: this.y\r\n      });\r\n    }\r\n\r\n    var scrollLeft = document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft;\r\n    var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;\r\n\r\n    var pX = this.pointX - scrollLeft;\r\n    var pY = this.pointY - scrollTop;\r\n\r\n    if (pX > document.documentElement.clientWidth - this.options.momentumLimitDistance || pX < this.options.momentumLimitDistance || pY < this.options.momentumLimitDistance || pY > document.documentElement.clientHeight - this.options.momentumLimitDistance) {\r\n      this._end(e);\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._end = function (e) {\r\n    if (!this.enabled || this.destroyed || eventType[e.type] !== this.initiated) {\r\n      return;\r\n    }\r\n    this.initiated = false;\r\n\r\n    if (this.options.preventDefault && !preventDefaultException(e.target, this.options.preventDefaultException)) {\r\n      e.preventDefault();\r\n    }\r\n\r\n    this.trigger('touchEnd', {\r\n      x: this.x,\r\n      y: this.y\r\n    });\r\n\r\n    var preventClick = this.stopFromTransition;\r\n    this.stopFromTransition = false;\r\n\r\n    // if configure pull down refresh, check it first\r\n    if (this.options.pullDownRefresh && this._checkPullDown()) {\r\n      return;\r\n    }\r\n\r\n    // reset if we are outside of the boundaries\r\n    if (this.resetPosition(this.options.bounceTime, ease.bounce)) {\r\n      return;\r\n    }\r\n    this.isInTransition = false;\r\n    // ensures that the last position is rounded\r\n    var newX = Math.round(this.x);\r\n    var newY = Math.round(this.y);\r\n\r\n    // we scrolled less than 15 pixels\r\n    if (!this.moved) {\r\n      if (this.options.wheel) {\r\n        if (this.target && this.target.className === this.options.wheel.wheelWrapperClass) {\r\n          var index = Math.abs(Math.round(newY / this.itemHeight));\r\n          var _offset = Math.round((this.pointY + offset(this.target).top - this.itemHeight / 2) / this.itemHeight);\r\n          this.target = this.items[index + _offset];\r\n        }\r\n        this.scrollToElement(this.target, this.options.wheel.adjustTime || 400, true, true, ease.swipe);\r\n      } else {\r\n        if (!preventClick) {\r\n          if (this.options.tap) {\r\n            tap(e, this.options.tap);\r\n          }\r\n\r\n          if (this.options.click) {\r\n            click(e);\r\n          }\r\n        }\r\n      }\r\n      this.trigger('scrollCancel');\r\n      return;\r\n    }\r\n\r\n    this.scrollTo(newX, newY);\r\n\r\n    var deltaX = newX - this.absStartX;\r\n    var deltaY = newY - this.absStartY;\r\n    this.directionX = deltaX > 0 ? DIRECTION_RIGHT : deltaX < 0 ? DIRECTION_LEFT : 0;\r\n    this.directionY = deltaY > 0 ? DIRECTION_DOWN : deltaY < 0 ? DIRECTION_UP : 0;\r\n\r\n    this.endTime = getNow();\r\n\r\n    var duration = this.endTime - this.startTime;\r\n    var absDistX = Math.abs(newX - this.startX);\r\n    var absDistY = Math.abs(newY - this.startY);\r\n\r\n    // flick\r\n    if (this._events.flick && duration < this.options.flickLimitTime && absDistX < this.options.flickLimitDistance && absDistY < this.options.flickLimitDistance) {\r\n      this.trigger('flick');\r\n      return;\r\n    }\r\n\r\n    var time = 0;\r\n    // start momentum animation if needed\r\n    if (this.options.momentum && duration < this.options.momentumLimitTime && (absDistY > this.options.momentumLimitDistance || absDistX > this.options.momentumLimitDistance)) {\r\n      var momentumX = this.hasHorizontalScroll ? momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options) : { destination: newX, duration: 0 };\r\n      var momentumY = this.hasVerticalScroll ? momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options) : { destination: newY, duration: 0 };\r\n      newX = momentumX.destination;\r\n      newY = momentumY.destination;\r\n      time = Math.max(momentumX.duration, momentumY.duration);\r\n      this.isInTransition = true;\r\n    } else {\r\n      if (this.options.wheel) {\r\n        newY = Math.round(newY / this.itemHeight) * this.itemHeight;\r\n        time = this.options.wheel.adjustTime || 400;\r\n      }\r\n    }\r\n\r\n    var easing = ease.swipe;\r\n    if (this.options.snap) {\r\n      var snap = this._nearestSnap(newX, newY);\r\n      this.currentPage = snap;\r\n      time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);\r\n      newX = snap.x;\r\n      newY = snap.y;\r\n\r\n      this.directionX = 0;\r\n      this.directionY = 0;\r\n      easing = ease.bounce;\r\n    }\r\n\r\n    if (newX !== this.x || newY !== this.y) {\r\n      // change easing function when scroller goes out of the boundaries\r\n      if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {\r\n        easing = ease.swipeBounce;\r\n      }\r\n      this.scrollTo(newX, newY, time, easing);\r\n      return;\r\n    }\r\n\r\n    if (this.options.wheel) {\r\n      this.selectedIndex = Math.round(Math.abs(this.y / this.itemHeight));\r\n    }\r\n    this.trigger('scrollEnd', {\r\n      x: this.x,\r\n      y: this.y\r\n    });\r\n  };\r\n\r\n  BScroll.prototype._resize = function () {\r\n    var _this = this;\r\n\r\n    if (!this.enabled) {\r\n      return;\r\n    }\r\n\r\n    clearTimeout(this.resizeTimeout);\r\n    this.resizeTimeout = setTimeout(function () {\r\n      _this.refresh();\r\n    }, this.options.resizePolling);\r\n  };\r\n\r\n  BScroll.prototype._startProbe = function () {\r\n    cancelAnimationFrame(this.probeTimer);\r\n    this.probeTimer = requestAnimationFrame(probe);\r\n\r\n    var me = this;\r\n\r\n    function probe() {\r\n      if (!me.isInTransition) {\r\n        return;\r\n      }\r\n      var pos = me.getComputedPosition();\r\n      me.trigger('scroll', pos);\r\n      me.probeTimer = requestAnimationFrame(probe);\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._transitionProperty = function () {\r\n    var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';\r\n\r\n    this.scrollerStyle[style.transitionProperty] = property;\r\n  };\r\n\r\n  BScroll.prototype._transitionTime = function () {\r\n    var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\r\n\r\n    this.scrollerStyle[style.transitionDuration] = time + 'ms';\r\n\r\n    if (this.options.wheel) {\r\n      for (var i = 0; i < this.items.length; i++) {\r\n        this.items[i].style[style.transitionDuration] = time + 'ms';\r\n      }\r\n    }\r\n\r\n    if (this.indicators) {\r\n      for (var _i = 0; _i < this.indicators.length; _i++) {\r\n        this.indicators[_i].transitionTime(time);\r\n      }\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._transitionTimingFunction = function (easing) {\r\n    this.scrollerStyle[style.transitionTimingFunction] = easing;\r\n\r\n    if (this.options.wheel) {\r\n      for (var i = 0; i < this.items.length; i++) {\r\n        this.items[i].style[style.transitionTimingFunction] = easing;\r\n      }\r\n    }\r\n\r\n    if (this.indicators) {\r\n      for (var _i2 = 0; _i2 < this.indicators.length; _i2++) {\r\n        this.indicators[_i2].transitionTimingFunction(easing);\r\n      }\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._transitionEnd = function (e) {\r\n    if (e.target !== this.scroller || !this.isInTransition) {\r\n      return;\r\n    }\r\n\r\n    this._transitionTime();\r\n    if (!this.pulling && !this.resetPosition(this.options.bounceTime, ease.bounce)) {\r\n      this.isInTransition = false;\r\n      this.trigger('scrollEnd', {\r\n        x: this.x,\r\n        y: this.y\r\n      });\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._translate = function (x, y) {\r\n    if (this.options.useTransform) {\r\n      this.scrollerStyle[style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;\r\n    } else {\r\n      x = Math.round(x);\r\n      y = Math.round(y);\r\n      this.scrollerStyle.left = x + 'px';\r\n      this.scrollerStyle.top = y + 'px';\r\n    }\r\n\r\n    if (this.options.wheel) {\r\n      var _options$wheel$rotate = this.options.wheel.rotate,\r\n          rotate = _options$wheel$rotate === undefined ? 25 : _options$wheel$rotate;\r\n\r\n      for (var i = 0; i < this.items.length; i++) {\r\n        var deg = rotate * (y / this.itemHeight + i);\r\n        this.items[i].style[style.transform] = 'rotateX(' + deg + 'deg)';\r\n      }\r\n    }\r\n\r\n    this.x = x;\r\n    this.y = y;\r\n\r\n    if (this.indicators) {\r\n      for (var _i3 = 0; _i3 < this.indicators.length; _i3++) {\r\n        this.indicators[_i3].updatePosition();\r\n      }\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._animate = function (destX, destY, duration, easingFn) {\r\n    var me = this;\r\n    var startX = this.x;\r\n    var startY = this.y;\r\n    var startTime = getNow();\r\n    var destTime = startTime + duration;\r\n\r\n    function step() {\r\n      var now = getNow();\r\n\r\n      if (now >= destTime) {\r\n        me.isAnimating = false;\r\n        me._translate(destX, destY);\r\n\r\n        if (!me.pulling && !me.resetPosition(me.options.bounceTime)) {\r\n          me.trigger('scrollEnd', {\r\n            x: me.x,\r\n            y: me.y\r\n          });\r\n        }\r\n        return;\r\n      }\r\n      now = (now - startTime) / duration;\r\n      var easing = easingFn(now);\r\n      var newX = (destX - startX) * easing + startX;\r\n      var newY = (destY - startY) * easing + startY;\r\n\r\n      me._translate(newX, newY);\r\n\r\n      if (me.isAnimating) {\r\n        me.animateTimer = requestAnimationFrame(step);\r\n      }\r\n\r\n      if (me.options.probeType === 3) {\r\n        me.trigger('scroll', {\r\n          x: me.x,\r\n          y: me.y\r\n        });\r\n      }\r\n    }\r\n\r\n    this.isAnimating = true;\r\n    cancelAnimationFrame(this.animateTimer);\r\n    step();\r\n  };\r\n\r\n  BScroll.prototype.scrollBy = function (x, y) {\r\n    var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\r\n    var easing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ease.bounce;\r\n\r\n    x = this.x + x;\r\n    y = this.y + y;\r\n\r\n    this.scrollTo(x, y, time, easing);\r\n  };\r\n\r\n  BScroll.prototype.scrollTo = function (x, y) {\r\n    var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\r\n    var easing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ease.bounce;\r\n\r\n    this.isInTransition = this.options.useTransition && time > 0 && (x !== this.x || y !== this.y);\r\n\r\n    if (!time || this.options.useTransition) {\r\n      this._transitionProperty();\r\n      this._transitionTimingFunction(easing.style);\r\n      this._transitionTime(time);\r\n      this._translate(x, y);\r\n\r\n      if (time && this.options.probeType === 3) {\r\n        this._startProbe();\r\n      }\r\n\r\n      if (this.options.wheel) {\r\n        if (y > 0) {\r\n          this.selectedIndex = 0;\r\n        } else if (y < this.maxScrollY) {\r\n          this.selectedIndex = this.items.length - 1;\r\n        } else {\r\n          this.selectedIndex = Math.round(Math.abs(y / this.itemHeight));\r\n        }\r\n      }\r\n    } else {\r\n      this._animate(x, y, time, easing.fn);\r\n    }\r\n  };\r\n\r\n  BScroll.prototype.scrollToElement = function (el, time, offsetX, offsetY, easing) {\r\n    if (!el) {\r\n      return;\r\n    }\r\n    el = el.nodeType ? el : this.scroller.querySelector(el);\r\n\r\n    if (this.options.wheel && el.className !== this.options.wheel.wheelItemClass) {\r\n      return;\r\n    }\r\n\r\n    var pos = offset(el);\r\n    pos.left -= this.wrapperOffset.left;\r\n    pos.top -= this.wrapperOffset.top;\r\n\r\n    // if offsetX/Y are true we center the element to the screen\r\n    if (offsetX === true) {\r\n      offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);\r\n    }\r\n    if (offsetY === true) {\r\n      offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);\r\n    }\r\n\r\n    pos.left -= offsetX || 0;\r\n    pos.top -= offsetY || 0;\r\n    pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;\r\n    pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;\r\n\r\n    if (this.options.wheel) {\r\n      pos.top = Math.round(pos.top / this.itemHeight) * this.itemHeight;\r\n    }\r\n\r\n    this.scrollTo(pos.left, pos.top, time, easing);\r\n  };\r\n\r\n  BScroll.prototype.resetPosition = function () {\r\n    var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\r\n    var easeing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ease.bounce;\r\n\r\n    var x = this.x;\r\n    if (!this.hasHorizontalScroll || x > 0) {\r\n      x = 0;\r\n    } else if (x < this.maxScrollX) {\r\n      x = this.maxScrollX;\r\n    }\r\n\r\n    var y = this.y;\r\n    if (!this.hasVerticalScroll || y > 0) {\r\n      y = 0;\r\n    } else if (y < this.maxScrollY) {\r\n      y = this.maxScrollY;\r\n    }\r\n\r\n    if (x === this.x && y === this.y) {\r\n      return false;\r\n    }\r\n\r\n    this.scrollTo(x, y, time, easeing);\r\n\r\n    return true;\r\n  };\r\n\r\n  BScroll.prototype.getComputedPosition = function () {\r\n    var matrix = window.getComputedStyle(this.scroller, null);\r\n    var x = void 0;\r\n    var y = void 0;\r\n\r\n    if (this.options.useTransform) {\r\n      matrix = matrix[style.transform].split(')')[0].split(', ');\r\n      x = +(matrix[12] || matrix[4]);\r\n      y = +(matrix[13] || matrix[5]);\r\n    } else {\r\n      x = +matrix.left.replace(/[^-\\d.]/g, '');\r\n      y = +matrix.top.replace(/[^-\\d.]/g, '');\r\n    }\r\n\r\n    return {\r\n      x: x,\r\n      y: y\r\n    };\r\n  };\r\n\r\n  BScroll.prototype.stop = function () {\r\n    if (this.options.useTransition && this.isInTransition) {\r\n      this.isInTransition = false;\r\n      var pos = this.getComputedPosition();\r\n      this._translate(pos.x, pos.y);\r\n      if (this.options.wheel) {\r\n        this.target = this.items[Math.round(-pos.y / this.itemHeight)];\r\n      } else {\r\n        this.trigger('scrollEnd', {\r\n          x: this.x,\r\n          y: this.y\r\n        });\r\n      }\r\n      this.stopFromTransition = true;\r\n    } else if (!this.options.useTransition && this.isAnimating) {\r\n      this.isAnimating = false;\r\n      this.trigger('scrollEnd', {\r\n        x: this.x,\r\n        y: this.y\r\n      });\r\n      this.stopFromTransition = true;\r\n    }\r\n  };\r\n\r\n  BScroll.prototype.destroy = function () {\r\n    this._removeDOMEvents();\r\n    // remove custom events\r\n    this._events = {};\r\n\r\n    if (this.options.scrollbar) {\r\n      this._removeScrollBars();\r\n    }\r\n\r\n    this.destroyed = true;\r\n    this.trigger('destroy');\r\n  };\r\n}\r\n\r\nfunction snapMixin(BScroll) {\r\n  BScroll.prototype._initSnap = function () {\r\n    var _this = this;\r\n\r\n    this.currentPage = {};\r\n    var snap = this.options.snap;\r\n\r\n    if (snap.loop) {\r\n      var children = this.scroller.children;\r\n      if (children.length > 0) {\r\n        prepend(children[children.length - 1].cloneNode(true), this.scroller);\r\n        this.scroller.appendChild(children[1].cloneNode(true));\r\n      }\r\n    }\r\n\r\n    var el = snap.el;\r\n    if (typeof el === 'string') {\r\n      el = this.scroller.querySelectorAll(el);\r\n    }\r\n\r\n    this.on('refresh', function () {\r\n      _this.pages = [];\r\n\r\n      if (!_this.wrapperWidth || !_this.wrapperHeight || !_this.scrollerWidth || !_this.scrollerHeight) {\r\n        return;\r\n      }\r\n\r\n      var stepX = snap.stepX || _this.wrapperWidth;\r\n      var stepY = snap.stepY || _this.wrapperHeight;\r\n\r\n      var x = 0;\r\n      var y = void 0;\r\n      var cx = void 0;\r\n      var cy = void 0;\r\n      var i = 0;\r\n      var l = void 0;\r\n      var m = 0;\r\n      var n = void 0;\r\n      var rect = void 0;\r\n      if (!el) {\r\n        cx = Math.round(stepX / 2);\r\n        cy = Math.round(stepY / 2);\r\n\r\n        while (x > -_this.scrollerWidth) {\r\n          _this.pages[i] = [];\r\n          l = 0;\r\n          y = 0;\r\n\r\n          while (y > -_this.scrollerHeight) {\r\n            _this.pages[i][l] = {\r\n              x: Math.max(x, _this.maxScrollX),\r\n              y: Math.max(y, _this.maxScrollY),\r\n              width: stepX,\r\n              height: stepY,\r\n              cx: x - cx,\r\n              cy: y - cy\r\n            };\r\n\r\n            y -= stepY;\r\n            l++;\r\n          }\r\n\r\n          x -= stepX;\r\n          i++;\r\n        }\r\n      } else {\r\n        l = el.length;\r\n        n = -1;\r\n\r\n        for (; i < l; i++) {\r\n          rect = getRect(el[i]);\r\n          if (i === 0 || rect.left <= getRect(el[i - 1]).left) {\r\n            m = 0;\r\n            n++;\r\n          }\r\n\r\n          if (!_this.pages[m]) {\r\n            _this.pages[m] = [];\r\n          }\r\n\r\n          x = Math.max(-rect.left, _this.maxScrollX);\r\n          y = Math.max(-rect.top, _this.maxScrollY);\r\n          cx = x - Math.round(rect.width / 2);\r\n          cy = y - Math.round(rect.height / 2);\r\n\r\n          _this.pages[m][n] = {\r\n            x: x,\r\n            y: y,\r\n            width: rect.width,\r\n            height: rect.height,\r\n            cx: cx,\r\n            cy: cy\r\n          };\r\n\r\n          if (x > _this.maxScrollX) {\r\n            m++;\r\n          }\r\n        }\r\n      }\r\n\r\n      var initPage = snap.loop ? 1 : 0;\r\n      _this.goToPage(_this.currentPage.pageX || initPage, _this.currentPage.pageY || 0, 0);\r\n\r\n      // Update snap threshold if needed\r\n      var snapThreshold = snap.threshold;\r\n      if (snapThreshold % 1 === 0) {\r\n        _this.snapThresholdX = snapThreshold;\r\n        _this.snapThresholdY = snapThreshold;\r\n      } else {\r\n        _this.snapThresholdX = Math.round(_this.pages[_this.currentPage.pageX][_this.currentPage.pageY].width * snapThreshold);\r\n        _this.snapThresholdY = Math.round(_this.pages[_this.currentPage.pageX][_this.currentPage.pageY].height * snapThreshold);\r\n      }\r\n    });\r\n\r\n    this.on('scrollEnd', function () {\r\n      if (snap.loop) {\r\n        if (_this.currentPage.pageX === 0) {\r\n          _this.goToPage(_this.pages.length - 2, _this.currentPage.pageY, 0);\r\n        }\r\n        if (_this.currentPage.pageX === _this.pages.length - 1) {\r\n          _this.goToPage(1, _this.currentPage.pageY, 0);\r\n        }\r\n      }\r\n    });\r\n\r\n    if (snap.listenFlick !== false) {\r\n      this.on('flick', function () {\r\n        var time = snap.speed || Math.max(Math.max(Math.min(Math.abs(_this.x - _this.startX), 1000), Math.min(Math.abs(_this.y - _this.startY), 1000)), 300);\r\n\r\n        _this.goToPage(_this.currentPage.pageX + _this.directionX, _this.currentPage.pageY + _this.directionY, time);\r\n      });\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._nearestSnap = function (x, y) {\r\n    if (!this.pages.length) {\r\n      return { x: 0, y: 0, pageX: 0, pageY: 0 };\r\n    }\r\n\r\n    var i = 0;\r\n    // Check if we exceeded the snap threshold\r\n    if (Math.abs(x - this.absStartX) <= this.snapThresholdX && Math.abs(y - this.absStartY) <= this.snapThresholdY) {\r\n      return this.currentPage;\r\n    }\r\n\r\n    if (x > 0) {\r\n      x = 0;\r\n    } else if (x < this.maxScrollX) {\r\n      x = this.maxScrollX;\r\n    }\r\n\r\n    if (y > 0) {\r\n      y = 0;\r\n    } else if (y < this.maxScrollY) {\r\n      y = this.maxScrollY;\r\n    }\r\n\r\n    var l = this.pages.length;\r\n    for (; i < l; i++) {\r\n      if (x >= this.pages[i][0].cx) {\r\n        x = this.pages[i][0].x;\r\n        break;\r\n      }\r\n    }\r\n\r\n    l = this.pages[i].length;\r\n\r\n    var m = 0;\r\n    for (; m < l; m++) {\r\n      if (y >= this.pages[0][m].cy) {\r\n        y = this.pages[0][m].y;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (i === this.currentPage.pageX) {\r\n      i += this.directionX;\r\n\r\n      if (i < 0) {\r\n        i = 0;\r\n      } else if (i >= this.pages.length) {\r\n        i = this.pages.length - 1;\r\n      }\r\n\r\n      x = this.pages[i][0].x;\r\n    }\r\n\r\n    if (m === this.currentPage.pageY) {\r\n      m += this.directionY;\r\n\r\n      if (m < 0) {\r\n        m = 0;\r\n      } else if (m >= this.pages[0].length) {\r\n        m = this.pages[0].length - 1;\r\n      }\r\n\r\n      y = this.pages[0][m].y;\r\n    }\r\n\r\n    return {\r\n      x: x,\r\n      y: y,\r\n      pageX: i,\r\n      pageY: m\r\n    };\r\n  };\r\n\r\n  BScroll.prototype.goToPage = function (x, y, time) {\r\n    var easing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ease.bounce;\r\n\r\n    var snap = this.options.snap;\r\n\r\n    if (!this.pages) {\r\n      return;\r\n    }\r\n\r\n    if (x >= this.pages.length) {\r\n      x = this.pages.length - 1;\r\n    } else if (x < 0) {\r\n      x = 0;\r\n    }\r\n\r\n    if (!this.pages[x]) {\r\n      return;\r\n    }\r\n\r\n    if (y >= this.pages[x].length) {\r\n      y = this.pages[x].length - 1;\r\n    } else if (y < 0) {\r\n      y = 0;\r\n    }\r\n\r\n    var posX = this.pages[x][y].x;\r\n    var posY = this.pages[x][y].y;\r\n\r\n    time = time === undefined ? snap.speed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;\r\n\r\n    this.currentPage = {\r\n      x: posX,\r\n      y: posY,\r\n      pageX: x,\r\n      pageY: y\r\n    };\r\n    this.scrollTo(posX, posY, time, easing);\r\n  };\r\n\r\n  BScroll.prototype.next = function (time, easing) {\r\n    var x = this.currentPage.pageX;\r\n    var y = this.currentPage.pageY;\r\n\r\n    x++;\r\n    if (x >= this.pages.length && this.hasVerticalScroll) {\r\n      x = 0;\r\n      y++;\r\n    }\r\n\r\n    this.goToPage(x, y, time, easing);\r\n  };\r\n\r\n  BScroll.prototype.prev = function (time, easing) {\r\n    var x = this.currentPage.pageX;\r\n    var y = this.currentPage.pageY;\r\n\r\n    x--;\r\n    if (x < 0 && this.hasVerticalScroll) {\r\n      x = 0;\r\n      y--;\r\n    }\r\n\r\n    this.goToPage(x, y, time, easing);\r\n  };\r\n\r\n  BScroll.prototype.getCurrentPage = function () {\r\n    return this.options.snap && this.currentPage;\r\n  };\r\n}\r\n\r\nfunction warn(msg) {\r\n  console.error(\"[BScroll warn]: \" + msg);\r\n}\r\n\r\nfunction wheelMixin(BScroll) {\r\n  BScroll.prototype.wheelTo = function () {\r\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\r\n\r\n    if (this.options.wheel) {\r\n      this.y = -index * this.itemHeight;\r\n      this.scrollTo(0, this.y);\r\n    }\r\n  };\r\n\r\n  BScroll.prototype.getSelectedIndex = function () {\r\n    return this.options.wheel && this.selectedIndex;\r\n  };\r\n\r\n  BScroll.prototype._initWheel = function () {\r\n    var wheel = this.options.wheel;\r\n    if (!wheel.wheelWrapperClass) {\r\n      wheel.wheelWrapperClass = 'wheel-scroll';\r\n    }\r\n    if (!wheel.wheelItemClass) {\r\n      wheel.wheelItemClass = 'wheel-item';\r\n    }\r\n    if (wheel.selectedIndex === undefined) {\r\n      wheel.selectedIndex = 0;\r\n      warn('wheel option selectedIndex is required!');\r\n    }\r\n  };\r\n}\r\n\r\nvar INDICATOR_MIN_LEN = 8;\r\n\r\nfunction scrollbarMixin(BScroll) {\r\n  BScroll.prototype._initScrollbar = function () {\r\n    var _this = this;\r\n\r\n    var _options$scrollbar$fa = this.options.scrollbar.fade,\r\n        fade = _options$scrollbar$fa === undefined ? true : _options$scrollbar$fa;\r\n\r\n    this.indicators = [];\r\n    var indicator = void 0;\r\n\r\n    if (this.options.scrollX) {\r\n      indicator = {\r\n        el: createScrollbar('horizontal'),\r\n        direction: 'horizontal',\r\n        fade: fade\r\n      };\r\n      this._insertScrollBar(indicator.el);\r\n\r\n      this.indicators.push(new Indicator(this, indicator));\r\n    }\r\n\r\n    if (this.options.scrollY) {\r\n      indicator = {\r\n        el: createScrollbar('vertical'),\r\n        direction: 'vertical',\r\n        fade: fade\r\n      };\r\n      this._insertScrollBar(indicator.el);\r\n      this.indicators.push(new Indicator(this, indicator));\r\n    }\r\n\r\n    this.on('refresh', function () {\r\n      for (var i = 0; i < _this.indicators.length; i++) {\r\n        _this.indicators[i].refresh();\r\n      }\r\n    });\r\n\r\n    if (fade) {\r\n      this.on('scrollEnd', function () {\r\n        for (var i = 0; i < _this.indicators.length; i++) {\r\n          _this.indicators[i].fade();\r\n        }\r\n      });\r\n\r\n      this.on('scrollCancel', function () {\r\n        for (var i = 0; i < _this.indicators.length; i++) {\r\n          _this.indicators[i].fade();\r\n        }\r\n      });\r\n\r\n      this.on('scrollStart', function () {\r\n        for (var i = 0; i < _this.indicators.length; i++) {\r\n          _this.indicators[i].fade(true);\r\n        }\r\n      });\r\n\r\n      this.on('beforeScrollStart', function () {\r\n        for (var i = 0; i < _this.indicators.length; i++) {\r\n          _this.indicators[i].fade(true, true);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  BScroll.prototype._insertScrollBar = function (scrollbar) {\r\n    this.wrapper.appendChild(scrollbar);\r\n  };\r\n\r\n  BScroll.prototype._removeScrollBars = function () {\r\n    for (var i = 0; i < this.indicators.length; i++) {\r\n      var indicator = this.indicators[i];\r\n      indicator.remove();\r\n    }\r\n  };\r\n}\r\n\r\nfunction createScrollbar(direction) {\r\n  var scrollbar = document.createElement('div');\r\n  var indicator = document.createElement('div');\r\n\r\n  scrollbar.style.cssText = 'position:absolute;z-index:9999;pointerEvents:none';\r\n  indicator.style.cssText = 'box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px;';\r\n\r\n  indicator.className = 'bscroll-indicator';\r\n\r\n  if (direction === 'horizontal') {\r\n    scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';\r\n    indicator.style.height = '100%';\r\n    scrollbar.className = 'bscroll-horizontal-scrollbar';\r\n  } else {\r\n    scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';\r\n    indicator.style.width = '100%';\r\n    scrollbar.className = 'bscroll-vertical-scrollbar';\r\n  }\r\n\r\n  scrollbar.style.cssText += ';overflow:hidden';\r\n  scrollbar.appendChild(indicator);\r\n\r\n  return scrollbar;\r\n}\r\n\r\nfunction Indicator(scroller, options) {\r\n  this.wrapper = options.el;\r\n  this.wrapperStyle = this.wrapper.style;\r\n  this.indicator = this.wrapper.children[0];\r\n  this.indicatorStyle = this.indicator.style;\r\n  this.scroller = scroller;\r\n  this.direction = options.direction;\r\n  if (options.fade) {\r\n    this.visible = 0;\r\n    this.wrapperStyle.opacity = '0';\r\n  } else {\r\n    this.visible = 1;\r\n  }\r\n}\r\n\r\nIndicator.prototype.refresh = function () {\r\n  this.transitionTime();\r\n  this._calculate();\r\n  this.updatePosition();\r\n};\r\n\r\nIndicator.prototype.fade = function (visible, hold) {\r\n  var _this2 = this;\r\n\r\n  if (hold && !this.visible) {\r\n    return;\r\n  }\r\n\r\n  var time = visible ? 250 : 500;\r\n\r\n  visible = visible ? '1' : '0';\r\n\r\n  this.wrapperStyle[style.transitionDuration] = time + 'ms';\r\n\r\n  clearTimeout(this.fadeTimeout);\r\n  this.fadeTimeout = setTimeout(function () {\r\n    _this2.wrapperStyle.opacity = visible;\r\n    _this2.visible = +visible;\r\n  }, 0);\r\n};\r\n\r\nIndicator.prototype.updatePosition = function () {\r\n  if (this.direction === 'vertical') {\r\n    var y = Math.round(this.sizeRatioY * this.scroller.y);\r\n\r\n    if (y < 0) {\r\n      this.transitionTime(500);\r\n      var height = Math.max(this.indicatorHeight + y * 3, INDICATOR_MIN_LEN);\r\n      this.indicatorStyle.height = height + 'px';\r\n      y = 0;\r\n    } else if (y > this.maxPosY) {\r\n      this.transitionTime(500);\r\n      var _height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, INDICATOR_MIN_LEN);\r\n      this.indicatorStyle.height = _height + 'px';\r\n      y = this.maxPosY + this.indicatorHeight - _height;\r\n    } else {\r\n      this.indicatorStyle.height = this.indicatorHeight + 'px';\r\n    }\r\n    this.y = y;\r\n\r\n    if (this.scroller.options.useTransform) {\r\n      this.indicatorStyle[style.transform] = 'translateY(' + y + 'px)' + this.scroller.translateZ;\r\n    } else {\r\n      this.indicatorStyle.top = y + 'px';\r\n    }\r\n  } else {\r\n    var x = Math.round(this.sizeRatioX * this.scroller.x);\r\n\r\n    if (x < 0) {\r\n      this.transitionTime(500);\r\n      var width = Math.max(this.indicatorWidth + x * 3, INDICATOR_MIN_LEN);\r\n      this.indicatorStyle.width = width + 'px';\r\n      x = 0;\r\n    } else if (x > this.maxPosX) {\r\n      this.transitionTime(500);\r\n      var _width = Math.max(this.indicatorWidth - (x - this.maxPosX) * 3, INDICATOR_MIN_LEN);\r\n      this.indicatorStyle.width = _width + 'px';\r\n      x = this.maxPosX + this.indicatorWidth - _width;\r\n    } else {\r\n      this.indicatorStyle.width = this.indicatorWidth + 'px';\r\n    }\r\n\r\n    this.x = x;\r\n\r\n    if (this.scroller.options.useTransform) {\r\n      this.indicatorStyle[style.transform] = 'translateX(' + x + 'px)' + this.scroller.translateZ;\r\n    } else {\r\n      this.indicatorStyle.left = x + 'px';\r\n    }\r\n  }\r\n};\r\n\r\nIndicator.prototype.transitionTime = function () {\r\n  var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\r\n\r\n  this.indicatorStyle[style.transitionDuration] = time + 'ms';\r\n};\r\n\r\nIndicator.prototype.transitionTimingFunction = function (easing) {\r\n  this.indicatorStyle[style.transitionTimingFunction] = easing;\r\n};\r\n\r\nIndicator.prototype.remove = function () {\r\n  this.wrapper.parentNode.removeChild(this.wrapper);\r\n};\r\n\r\nIndicator.prototype._calculate = function () {\r\n  if (this.direction === 'vertical') {\r\n    var wrapperHeight = this.wrapper.clientHeight;\r\n    this.indicatorHeight = Math.max(Math.round(wrapperHeight * wrapperHeight / (this.scroller.scrollerHeight || wrapperHeight || 1)), INDICATOR_MIN_LEN);\r\n    this.indicatorStyle.height = this.indicatorHeight + 'px';\r\n\r\n    this.maxPosY = wrapperHeight - this.indicatorHeight;\r\n\r\n    this.sizeRatioY = this.maxPosY / this.scroller.maxScrollY;\r\n  } else {\r\n    var wrapperWidth = this.wrapper.clientWidth;\r\n    this.indicatorWidth = Math.max(Math.round(wrapperWidth * wrapperWidth / (this.scroller.scrollerWidth || wrapperWidth || 1)), INDICATOR_MIN_LEN);\r\n    this.indicatorStyle.width = this.indicatorWidth + 'px';\r\n\r\n    this.maxPosX = wrapperWidth - this.indicatorWidth;\r\n\r\n    this.sizeRatioX = this.maxPosX / this.scroller.maxScrollX;\r\n  }\r\n};\r\n\r\nfunction pullDownMixin(BScroll) {\r\n  BScroll.prototype._initPullDown = function () {\r\n    // must watch scroll in real time\r\n    this.options.probeType = 3;\r\n  };\r\n\r\n  BScroll.prototype._checkPullDown = function () {\r\n    var _options$pullDownRefr = this.options.pullDownRefresh,\r\n        _options$pullDownRefr2 = _options$pullDownRefr.threshold,\r\n        threshold = _options$pullDownRefr2 === undefined ? 90 : _options$pullDownRefr2,\r\n        _options$pullDownRefr3 = _options$pullDownRefr.stop,\r\n        stop = _options$pullDownRefr3 === undefined ? 40 : _options$pullDownRefr3;\r\n\r\n    // check if a real pull down action\r\n\r\n    if (this.movingDirectionY !== DIRECTION_DOWN || this.y < threshold) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.pulling) {\r\n      this.pulling = true;\r\n      this.trigger('pullingDown');\r\n    }\r\n    this.scrollTo(this.x, stop, this.options.bounceTime, ease.bounce);\r\n\r\n    return this.pulling;\r\n  };\r\n\r\n  BScroll.prototype.finishPullDown = function () {\r\n    this.pulling = false;\r\n    this.resetPosition(this.options.bounceTime, ease.bounce);\r\n  };\r\n}\r\n\r\nfunction pullUpMixin(BScroll) {\r\n  BScroll.prototype._initPullUp = function () {\r\n    // must watch scroll in real time\r\n    this.options.probeType = 3;\r\n\r\n    this.pullupWatching = false;\r\n    this._watchPullUp();\r\n  };\r\n\r\n  BScroll.prototype._watchPullUp = function () {\r\n    if (this.pullupWatching) {\r\n      return;\r\n    }\r\n    this.pullupWatching = true;\r\n    var _options$pullUpLoad$t = this.options.pullUpLoad.threshold,\r\n        threshold = _options$pullUpLoad$t === undefined ? 0 : _options$pullUpLoad$t;\r\n\r\n\r\n    this.on('scroll', checkToEnd);\r\n\r\n    function checkToEnd(pos) {\r\n      if (this.movingDirectionY === DIRECTION_UP && pos.y <= this.maxScrollY + threshold) {\r\n        this.trigger('pullingUp');\r\n        this.pullupWatching = false;\r\n        this.off('scroll', checkToEnd);\r\n      }\r\n    }\r\n  };\r\n\r\n  BScroll.prototype.finishPullUp = function () {\r\n    var _this = this;\r\n\r\n    if (this.isInTransition) {\r\n      this.once('scrollEnd', function () {\r\n        _this._watchPullUp();\r\n      });\r\n    } else {\r\n      this._watchPullUp();\r\n    }\r\n  };\r\n}\r\n\r\nfunction BScroll(el, options) {\r\n  this.wrapper = typeof el === 'string' ? document.querySelector(el) : el;\r\n  if (!this.wrapper) {\r\n    warn('can not resolve the wrapper dom');\r\n  }\r\n  this.scroller = this.wrapper.children[0];\r\n  if (!this.scroller) {\r\n    warn('the wrapper need at least one child element to be scroller');\r\n  }\r\n  // cache style for better performance\r\n  this.scrollerStyle = this.scroller.style;\r\n\r\n  this._init(el, options);\r\n}\r\n\r\ninitMixin(BScroll);\r\ncoreMixin(BScroll);\r\neventMixin(BScroll);\r\nsnapMixin(BScroll);\r\nwheelMixin(BScroll);\r\nscrollbarMixin(BScroll);\r\npullDownMixin(BScroll);\r\npullUpMixin(BScroll);\r\n\r\nBScroll.Version = '1.5.4';\r\n\r\nreturn BScroll;\r\n\r\n})));\r\n"},"hash":"ca2e682a0fb979ed4be75f5bc15e4c57"}